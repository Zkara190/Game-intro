#include <iostream>
#include <vector>
#include <string>

using namespace std;

class Events { // trees for events and choices
public:
	Events() : backhand(NULL), deathprompt(NULL), forehand(NULL), response(NULL), combatNode(NULL) {}
	void event(string r, string d, Events *b, Events *f, Combats *c)
	{
		backhand = b; forehand = f; response = r; combatNode = c;
	}
	Events* getBack() { return backhand; }
	Events* getFore() { return forehand; }
	Combats* getCombat() { retrun combatNode; }
	void setResponse(char res) { response = res;}
	string getResponse() { return response; }
	string death() { return deathprompt; }
private:
	string response;
	string deathprompt = "You have met your doom!";
	Events* backhand; // left node
	Events* forehand; // right node
	Combats* combatNode;
};

class Combats { // second tree format to handle combat
public:
	Combats() : attack(NULL), defend(NULL), eventNode(NULL), response(NULL), deathprompt(NULL), {}
	// a & d are connections, event node returns back to main story, response is the contents of node, death is if the node is a death node
	void event( Combats *a, Combats *d, Events *e, string r)
	{
		attack = a; defend = d; eventNode = e; response = r;
	}
	Combats* getAttaack() { return backhand; }
	Combats* getDefend() { return forehand; }
	Events* getEvents() { return eventNode; }
	void setResponse(char res) { response = res;}
	string getResponse() { return response; }
	string death() { return deathprompt; }
private:
	string response;
	string deathprompt = "You have met your doom!";
    Combats* attack; // attack node
	Combats* defend; // defend node
	Events* eventNode;
};

string adventure(Events* T)
{
	if (T->getResponse() == "L") {
		return (adventure(T->getBack()));
	}
	else if (T->getResponse() == "R") {
		return (adventure(T->getFore()));
	}
	else return T->death();
}

int main()
{
	/*	
		vector<Node> A;  // create space for nodes
		int sizure;
		cin >> sizure;
		A.resize(sizure);
		A[0].my_init('+',0.0,&A[1],&A[2],NULL);
		A[1].my_init('n',2.0,NULL,NULL, NULL);

		cout << my_compute(&A[0]);
		cout << A[0].getOp();
	*/
		return 0;
	
}
